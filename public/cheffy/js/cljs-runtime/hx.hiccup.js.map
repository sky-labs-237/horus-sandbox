{"version":3,"sources":["hx/hiccup.cljc"],"mappings":"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","names":["x__4433__auto__","m__4434__auto__","hx.hiccup/-as-element","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","hx.hiccup/IElement","el","config","js/hx","js/hx.hiccup","js/hx.hiccup.tag-registry","hx.hiccup/tag-registry","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","hx.hiccup/extend-tag","tag","impl","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","hx.hiccup/tag->impl","temp__5733__auto__","t","cljs.core/deref","cljs.core.get.cljs$core$IFn$_invoke$arity$3","cljs.core/name","hx.hiccup/parse-tag","cljs.core/Keyword","cljs.core/var?","args","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","hx.hiccup/make-element","fexpr__26564","hx.hiccup/parse","hiccup","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","cljs.core/rest","hx.hiccup/ex","s","js/Error","goog.object/set","G__26567","G__26568","G__26569","G__26570","G__26571","G__26572","G__26573","G__26574","G__26575","cljs.core/PROTOCOL_SENTINEL","G__26576","G__26577","G__26578","G__26579","G__26580","G__26581","_","n","cljs.core/PersistentVector","form","cljs.core/LazySeq","a","cljs.core/cons","p1__26565#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__26566#","fexpr__26582","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","cljs.core/type"],"sourcesContent":["(ns hx.hiccup\n  (:require [clojure.walk :as walk]\n            [hx.utils :as util :include-macros true]))\n\n(defprotocol IElement\n  (-as-element [el config] \"Converts to an element\"))\n\n;; (declare -as-element)\n\n(defonce tag-registry (atom {}))\n\n(defn extend-tag [tag impl]\n  (swap! tag-registry assoc tag impl))\n\n(defn tag->impl [tag]\n  (if-let [t (get @tag-registry tag nil)]\n    t\n    (name tag)))\n\n;; ;; we use a multimethod to dispatch on identity so that consumers\n;; ;; can override this for custom values e.g. :<> for React fragments\n;; (defmulti extend-tag\n;;   identity\n;;   :default ::default)\n\n;; ;; if no multimethod for specific el, then apply general parsing rules\n;; (defmethod extend-tag\n;;   ::default\n;;   ([el]\n;;    (name el)))\n\n(defn parse-tag [el]\n  (cond\n    ^boolean (keyword? el) (tag->impl el)\n    ^boolean (var? el) (fn VarEl [& args] (apply el args))\n    true el))\n\n(defn make-element [config el args]\n  (util/measure-perf\n   \"make_element\"\n   ((:create-element config) config el args)))\n\n(defn parse [config hiccup]\n  (util/measure-perf\n   \"parse\"\n   (make-element config (parse-tag (nth hiccup 0)) (rest hiccup))))\n\n#?(:clj (defn array? [x]\n          (coll? x)))\n\n(defn ex [s]\n  #?(:clj (Exception. s)\n     :cljs (js/Error. s)))\n\n(extend-protocol IElement\n  nil\n  (-as-element [_ _]\n    (util/measure-perf\n     \"-as_element_nil\"\n     nil))\n\n  #?(:clj Number\n     :cljs number)\n  (-as-element [n _]\n    (util/measure-perf\n     \"-as_element_number\"\n     n))\n\n  #?(:clj String\n     :cljs string)\n  (-as-element [s _]\n    (util/measure-perf\n     \"-as_element_string\"\n     s))\n\n  #?(:clj clojure.lang.PersistentVector\n     :cljs PersistentVector)\n  (-as-element [form config]\n    (util/measure-perf\n     \"-as_element_vector\"\n     (make-element config (parse-tag (nth form 0)) (rest form))))\n\n  #?(:clj clojure.lang.LazySeq\n     :cljs LazySeq)\n  (-as-element [a config]\n    (util/measure-perf\n     \"-as_element_lazyseq\"\n     (make-element\n      config\n      (:fragment config)\n      (cons nil (map #(-as-element % config) a)))))\n\n  #?(:cljs array)\n  #?(:cljs (-as-element [a config]\n                        (util/measure-perf\n                         \"-as_element_array\"\n                         (make-element\n                          config\n                          (:fragment config)\n                          (cons nil (map #(-as-element % config) a))))))\n\n  #?(:clj Object\n     :cljs default)\n  (-as-element [el config]\n    (cond\n      ((:is-element? config) el) el\n\n      :default\n      (throw\n       (ex (str \"Unknown element type \" (pr-str (type el))\n                \" found while parsing hiccup form: \"\n                (.toString el)))))))\n"]}