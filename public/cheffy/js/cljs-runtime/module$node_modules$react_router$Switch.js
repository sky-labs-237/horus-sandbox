shadow$provide.module$node_modules$react_router$Switch=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}});
superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}exports.__esModule=!0;global=require("module$node_modules$react$index");var _react2=_interopRequireDefault(global);global=require("module$node_modules$prop_types$index");global=_interopRequireDefault(global);module=require("module$node_modules$warning$warning");var _warning2=_interopRequireDefault(module);module=require("module$node_modules$invariant$browser");var _invariant2=_interopRequireDefault(module);
require=require("module$node_modules$react_router$matchPath");var _matchPath2=_interopRequireDefault(require);require=function(_React$Component){function Switch(){if(!(this instanceof Switch))throw new TypeError("Cannot call a class as a function");var call=_React$Component.apply(this,arguments);if(!this)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?this:call}_inherits(Switch,_React$Component);Switch.prototype.componentWillMount=
function(){(0,_invariant2.default)(this.context.router,"You should not use \x3cSwitch\x3e outside a \x3cRouter\x3e")};Switch.prototype.componentWillReceiveProps=function(nextProps){(0,_warning2.default)(!(nextProps.location&&!this.props.location),'\x3cSwitch\x3e elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');(0,_warning2.default)(!(!nextProps.location&&this.props.location),'\x3cSwitch\x3e elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.')};
Switch.prototype.render=function(){var route=this.context.router.route,location=this.props.location||route.location,match=void 0,child=void 0;_react2.default.Children.forEach(this.props.children,function(element){if(null==match&&_react2.default.isValidElement(element)){var _element$props=element.props,exact=_element$props.exact,strict=_element$props.strict,sensitive=_element$props.sensitive,from=_element$props.from;_element$props=_element$props.path||from;child=element;match=(0,_matchPath2.default)(location.pathname,
{path:_element$props,exact:exact,strict:strict,sensitive:sensitive},route.match)}});return match?_react2.default.cloneElement(child,{location:location,computedMatch:match}):null};return Switch}(_react2.default.Component);require.contextTypes={router:global.default.shape({route:global.default.object.isRequired}).isRequired};require.propTypes={children:global.default.node,location:global.default.object};exports.default=require}
//# sourceMappingURL=module$node_modules$react_router$Switch.js.map
