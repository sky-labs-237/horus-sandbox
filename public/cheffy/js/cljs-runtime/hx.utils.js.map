{"version":3,"sources":["hx/utils.cljs"],"mappings":"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","names":["hx.utils/keyword->str","k","kw-ns","cljs.core/namespace","kw-name","cljs.core/name","hx.utils/props->clj","props","ks","js/Object.keys","m","cljs.core/first","v","goog.object/get","cljs.core/next","G__26530","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","hx.utils/set-obj","o","goog.object/set","hx.utils/join-classes","classes","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/nil?","clojure.string.join.cljs$core$IFn$_invoke$arity$2","hx.utils/class-name","x","cljs.core/Keyword","cljs.core/sequential?","cljs.core/set?","hx.utils/camel-case*","s","cljs.core/Symbol","vec__26531","seq__26532","cljs.core/seq","first__26533","first-word","words","clojure.string.split.cljs$core$IFn$_invoke$arity$2","cljs.core/empty?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","clojure.string/capitalize","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","clojure.string.join.cljs$core$IFn$_invoke$arity$1","hx.utils/map->camel+js","cljs.core/map?","ps","p","cljs.core/key","cljs.core/val","var_args","G__26535","hx.utils/clj->props","js/Error","hx.utils.clj__GT_props.cljs$core$IFn$_invoke$arity$2","native?","pxs","js-props","G__26536"],"sourcesContent":["(ns hx.utils\n  (:require [clojure.string :as str]\n            [goog.object :as gobj]))\n\n(defn keyword->str [k]\n  (let [kw-ns (namespace k)\n        kw-name (name k)]\n    (if (nil? kw-ns)\n      kw-name\n\n      (str kw-ns \"/\" kw-name))))\n\n\n(defn props->clj [props]\n  (loop [ks (js/Object.keys props)\n         m {}]\n    (if (nil? ks)\n      m\n      (let [k (first ks)\n            v (gobj/get props k)]\n        (recur (next ks)\n               (case k\n                 ;; backwards compat\n                 \"class\" (assoc m\n                                :className v\n                                :class v)\n                 \"className\" (assoc m\n                                    :className v\n                                    :class v)\n                 \"htmlFor\" (assoc m\n                                  :htmlFor v\n                                  :for v)\n                 (assoc m (keyword k) v)))))))\n\n(comment\n  (props->clj #js {:class \"foo\"})\n  )\n\n\n(defn- set-obj [o k v]\n  (do (gobj/set o k v)\n      o))\n\n(defn- join-classes\n  \"Join the `classes` with a whitespace.\"\n  [classes]\n  (->> classes\n       (remove nil?)\n       (str/join \" \")))\n\n(defn- class-name [x]\n  (cond (or (nil? x)\n            (keyword? x)\n            (string? x))\n        x\n\n        (or (sequential? x)\n            (set? x))\n        (join-classes x)\n\n        :else x))\n\n(defn- camel-case*\n  \"Returns camel case version of the string, e.g. \\\"http-equiv\\\" becomes \\\"httpEquiv\\\".\"\n  [s]\n  (if (or (keyword? s)\n          (string? s)\n          (symbol? s))\n    (let [[first-word & words] (str/split (name s) #\"-\")]\n      (if (or (empty? words)\n              (= \"aria\" first-word)\n              (= \"data\" first-word))\n        s\n        (-> (map str/capitalize words)\n            (conj first-word)\n            str/join)))\n    s))\n\n(defn- map->camel+js [x]\n  (cond\n    (map? x) (loop [ps (seq x)\n                    o #js {}]\n               (if (nil? ps)\n                 o\n                 (let [p (first ps)\n                       k (key p)\n                       v (val p)]\n                   ;; side-effecting\n                   (set-obj o (camel-case* (name k)) (map->camel+js v))\n                   (recur (next ps)\n                          o))))\n    true x))\n\n(comment\n  (map->camel+js {})\n\n  (map->camel+js {:color \"red\"})\n\n  (map->camel+js {:color \"red\" :background \"green\"})\n\n  (next [1 2])\n  )\n\n(defn clj->props\n  \"Shallowly converts props map to a JS obj. Handles certain special cases:\n\n  1. `:class` -> \\\"className\\\", and joins collections together as a string\n  2. `:for` -> \\\"htmlFor\\\"\n  3. `:style` -> deeply converts this prop to a JS obj\n\n  By default, converts kebab-case keys to camelCase strings. pass in `false`\n  as a second arg to disable this.\"\n  ([props] (clj->props props true))\n  ([props native?]\n   (loop [pxs (seq props)\n          js-props #js {}]\n     (if (nil? pxs)\n       js-props\n       (let [p (first pxs)\n             k (key p)\n             v (val p)]\n         ;; side-effecting\n         (case k\n           :style (set-obj js-props \"style\" (map->camel+js v))\n           :class (if native?\n                    (set-obj js-props \"className\" (class-name v))\n                    (do (set-obj js-props \"class\" (class-name v))\n                        (set-obj js-props \"className\" (class-name v))))\n           :for (if native?\n                  (set-obj js-props \"htmlFor\" v)\n                  (do (set-obj js-props \"for\" v)\n                      (set-obj js-props \"htmlFor\" v)))\n\n           (set-obj js-props\n                    (if native?\n                      (camel-case* (keyword->str k))\n                      (keyword->str k))\n                    v))\n         (recur (next pxs)\n                js-props))))))\n\n(comment\n  (clj->props {:class \"foo\"\n               :style {:color \"red\"}})\n\n  (clj->props {:class [nil \"foo\"]})\n\n  (clj->props {:asdf \"jkl\"})\n\n  (let [case {:x-x? \"asdf\"}]\n    (-> (clj->props case)))\n\n  (let [case {:x-x.x? \"asdf\"}]\n    (-> (clj->props case)))\n\n  (let [case {:xa1-xb2.x? \"asdf\"}]\n    (-> (clj->props case)))\n\n\n  (let [case {:ns/xb2.x? \"asdf\"}]\n    (-> (clj->props case)))\n\n  (let [case {:ns/-xb2.x? \"asdf\"}]\n    (-> (clj->props case)))\n  )\n"]}