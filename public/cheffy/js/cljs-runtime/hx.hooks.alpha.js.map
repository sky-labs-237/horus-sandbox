{"version":3,"sources":["hx/hooks/alpha.cljs"],"mappings":";;;AAIA,AAAA,AAAAA,AAAAC,AAAAC,AAAAC;AAAA;AAAA,AAAA,AAASC,AAAO,AAAA,AAACC;;AAEjB;;;;;;AAAA,AAAMC,AAKHC,AAAQC;AALX,AASE,AAAMC,AAAK,AAACC,AAAS,AAAI,AAAA,AAAAC,AAACC,AAAWR,AAAOI,AACrB,AAAAK,AAAA,AAAAF,AAAEP;AAAF,AAAA,AAAAS,AAAAA,AAAAA,AAASL,AAAAA;AACTD;AACjBO,AAAa,AAAA,AAACC;AAHpB,AAKE,AAACC,AAAU;;AAAA,AACE,AAAA,AAAAL,AAAKG;AACH,AAACG,AAAMb,AAAOc,AAAMV,AAAE,AAACW,AAAMV;;AAC7B,AAAA,AAACW,AAAON;;;AAHvB,AAIY,AAACK,AAAMV;;AACnBA;;AAGJ;;;;;;AAAA,AAAMY,AAKHC,AAAQf,AAAQC;AALnB,AASE,AAAMC,AAAK,AAACc,AAAWD,AACA,AAAI,AAAA,AAAAX,AAACC,AAAWR,AAAOI,AACrB,AAAAgB,AAAA,AAAAb,AAAEP;AAAF,AAAA,AAAAoB,AAAAA,AAAAA,AAAShB,AAAAA;AACTD;AAHzB,AAIE,AAAMO,AAAa,AAAA,AAACC;AAApB,AAEE,AAACC,AAAU;;AAAA,AACE,AAAA,AAAAL,AAAKG;AACH,AAACG,AAAMb,AAAOc,AAAMV,AAAE,AAACW,AAAMV;;AAC7B,AAAA,AAACW,AAAON;;;AAHvB,AAIY,AAACK,AAAMV;;AACrBA","names":["js/hx","js/hx.hooks","js/hx.hooks.alpha","js/hx.hooks.alpha.states","hx.hooks.alpha/states","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","hx.hooks.alpha/useStateOnce","initial","k","hook","hx.hooks.useState.cljs$core$IFn$_invoke$arity$1","cljs.core/deref","cljs.core/contains?","fexpr__29288","has-mounted?","hx.hooks/useIRef","hx.hooks.useEffect.cljs$core$IFn$_invoke$arity$2","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","cljs.core/first","cljs.core/reset!","hx.hooks.alpha/useReducerOnce","reducer","hx.hooks.useReducer.cljs$core$IFn$_invoke$arity$2","fexpr__29290"],"sourcesContent":["(ns hx.hooks.alpha\n  (:require [hx.hooks :refer [useEffect useState useReducer useIRef useDebugValue]])\n  (:require-macros [hx.hooks.alpha]))\n\n(defonce states (atom {}))\n\n(defn useStateOnce\n  \"Like useState, but maintains your state across hot-reloads. `k` is a globally\n  unique key to ensure you always get the same state back.\n\n  Example: `(useStateOnce 0 ::counter)`\"\n  [initial k]\n  ;; if a state already exists with name `k`, then pass that value in\n  ;; otherwise, pass in the initial value.\n  ;; capture the hook returned by the higher-order hook passed in\n  (let [hook (useState (if (contains? @states k)\n                         (@states k)\n                         initial))\n        has-mounted? (useIRef false)]\n    ;; (useDebugValue (pr-str (first hook)))\n    (useEffect (fn []\n                 (if @has-mounted?\n                   (swap! states assoc k (first hook))\n                   (reset! has-mounted? true)))\n               [(first hook)])\n    hook)\n  )\n\n(defn useReducerOnce\n  \"Like useReducer, but maintains your state across hot-reloads. `k` is a globally\n  unique key to ensure you always get the same state back.\n\n  Example: `(useReducerOnce reducer initial ::counter)`\"\n  [reducer initial k]\n  ;; if a state already exists with name `k`, then pass that value in\n  ;; otherwise, pass in the initial value.\n  ;; capture the hook returned by the higher-order hook passed in\n  (let [hook (useReducer reducer\n                         (if (contains? @states k)\n                           (@states k)\n                           initial))]\n    (let [has-mounted? (useIRef false)]\n      ;; (useDebugValue (pr-str (first hook)))\n      (useEffect (fn []\n                   (if @has-mounted?\n                     (swap! states assoc k (first hook))\n                     (reset! has-mounted? true)))\n                 [(first hook)]))\n    hook))\n"]}